import 'macros' as {$}
_G.PROJECTNAME, _G.VERSION = $FILE\sub(1,-5), "0.1a(#{$DATE})"
import 'utf8'
import 'lib.lume'
-- import 'utl'
import 'utl' as :play
import 'lib.maid64' -- 改造して高解像度を初期値にした
-- import 'color' as :sweetie16
-- luacheck: ignore gifcat
-- import 'lib.gifcat' -- 全部に?入れているので、ここ消すだけで使わなくなる
import 'ui' as :Scene, :SelectBox, :BGM, :Watchdog
import 'input' as :input, :SoftGamepad
-- import 'BDF'
import 'lib.tween' -- 改造してdelayを可能にした
import 'bigmap' as :Map
import 'lib.bump'
-- vudu = if DEBUGMODE then require 'lib.vudu' else nil
inspect = if DEBUGMODE then require 'lib.inspect' else nil
local *

love.window.setTitle(PROJECTNAME .. ' - v' .. VERSION)
love.window.setMode(800, 512, if 'Android' == love.system.getOS() then {fullscreen: true, msaa:2} else {resizable: true, msaa: 2}) -- レトロ画面をコピーするだけならanti alias不要。gamepad描いているのでmsaaつけた
maid64.setup(256, 256)
-- maid64.canvas\setFilter('nearest') -- retro表現
love.mouse.getPosition = maid64.mouse.getPosition -- プログラム全体としてmaid64の座標系を使うことにする
love.touch.getPosition0 = love.touch.getPosition -- 保存
love.touch.getPosition = (id)-> maid64.transformPosition(love.touch.getPosition0(id))
maid64.clearBG = -> gr.draw_zoom(gr.newFlyweightImage('assets/Metal_02-800x512.jpg'))--'assets/wallpaper.jpg')) -- 壁紙
os.lang = nil -- i18nを無効
love.audio.setVolume(.65)

-- maid64.canvasの外(screen)に描く→描画時に位置などを調整
softgamepad = SoftGamepad(SoftGamepad.LURDABButtons256)

-- @diagnostic disable-next-line: duplicate-set-field
love.draw = ->
	love.draw1()
	softgamepad.font, font = gr.newFlyweightFont('assets/fonts/mplus/mplus-2p-black.subset.otf', 28*maid64.scaler), softgamepad.font
	softgamepad.buttons, buttons = {k, {x*maid64.scaler+maid64.x, y*maid64.scaler+maid64.y, r*maid64.scaler,label,pie} for k, {x,y,r,label,pie} in pairs softgamepad.buttons}, softgamepad.buttons
	softgamepad\draw()
	softgamepad.font, softgamepad.buttons = font, buttons


love.hiscore, love.score, love.coins, love.lives = 0, 0, 0, 3 -- lives:残機

LevelData =
	['1-1']:
		bgcolor: {lume.color'#5c94fc'}
		bgm: {'assets/supermario/maintheme_intro.ogg', 'assets/supermario/maintheme.ogg'} -- 最後をループする
		time: 400
		startpoints: {{48, 176+8}, {74*16, 176+8}} -- 2つ目以降は中間地点を表す。
		goal_x: 202*16+8
		warppoints: {{60*16+16, 7*16+16, key: 'Down', action: ->
			Scene.current.update = coroutine.wrap Scene.current._update土管入り
			Scene.current\update -> -- 初回呼び出しはactionを渡すのに使う(dtではなく)
				old = Scene.current
				Field('UnderworldA', old.player.__class)\attach()
				Scene.current.time, Scene.current.level = old.time, old.level
				Scene.current.warppoints[1].action = ->
					old = Scene.current
					Field('1-1', old.player.__class)\attach()
					Scene.current.time, _ = old.time, Scene.current.player\warp(165*16+8, 9*16)
					Scene.current.update = coroutine.wrap Scene.current._update土管出 -- こっちは渡すactionが無い。
		}, --{0, 257, action: -> Scene.current.player\warp(Scene.current.player.x-60, Scene.current.player.y-260)} -- 落下を死亡以外にすることができる
		}
		field: $to2d[[
~         ﾘ                                                                       ﾌ      ﾙ ﾌ     ﾌ                                                                                                                    ~
                  %'                    %&'             ｼ              %'             %&'                             %'              %&'      ｺｺｺ    ｺｺｺ       ｺｺｺ                                                   ~
    %'            57         %&&'       567                %'          57    %&&'     567    ﾀ             %'         57     %&&'     567   A       A     %' A                           %&'              3           ~
    57         ｰ             5667                          57                5667     ﾒ ﾒ    _             57                5667                         57                  %&&'   ｹ   567              4 %'        ~
            ﾊ         u                                                           AAAAAAA    AAAu     ﾓ        v           AAA    AuuA                                        5667              GG        4 57  ｯ     ~
            TU                                                                                                                                                                           ｹ     GGG        4           ~
         ﾉ  de                                                                                                                    ﾇ      ﾇ                                  ｹ                 GGGG        4    999    ~
            GG                                 ｸｸﾊ          ﾊ      z                            ﾀ                                                         ﾒ                                  GGGGG        4    111    ~
         Gﾘ     u   Av uA                ﾊ       TU         TU                 AvA              q     At    u  u  u     ｰ          AA      G  ﾀ          GG  G            AAAuA        ｸ    GGGGGG        4   99999   ~
   0    G  ｺ                  ﾊ          TU      de  0      de                                      0              ｸ      ﾒ               GG  GG    0   GGG  GG      ﾊ           ｹ     ﾊ   GGGGGGG        4   11111   ~
  ,-.  G                      TU        ﾉde      de ,-.     de      0                 ﾝ            ,-.        ﾉ  ｸ 0                     GGG  GGG  ,-. GGGG  GGG   0 TU              ｸ TU GGGGGGGG        4   11111  0~
 ;<=>?G     !""$    !$ ﾉ  ｸ ｸ de         de !""$ de;<=>?    de!"""$,-.    !$               !""$   ;<=>?      !"""$,-.    !$             GGGG""GGGG;<=>GGGGG  GGGG$,-.de  !$            deGGGGGGGGG        G   11111$,-.
FFFFFFFFFF  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFdeFFFFFFFFFF  FFFFFFFFFFFFFF   FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  FFFFFFFFdeFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]]
-- [注意] [spec] プラットフォームもモンスターも最小限にしか作られないので、生成されたモンスターが壁に当たって反対方向を向き歩いていくと、まだ床がないところに来れば落ちて消えてしまう。そのようなところに配置しないように気をつけなければならない
	['UnderworldA']:
		bgcolor: {0, 0, 0}
		sprites_offset: 0x70
		bgm: {'assets/supermario/underworld.ogg'}
		time: 400
		startpoints: {{16, 32} }
		warppoints: {{12*16+15, 11*16+15, key: 'Right', }} -- action(戻る場所)は呼ぶ側が定めるため、場所と起動キーのみ
		field: $to2d[[
~              ~
A   AAAAAAA    d
A              d
A              d
A    ｺｺｺｺｺ     d
A              d
A   ｺｺｺｺｺｺｺ    d
A              d
A   ｺｺｺｺｺｺｺ    d
A   AAAAAAA    d
A   AAAAAqA  VWX
A            fgh
FFFFFFFFFFFFFFFF]]
LevelData.title = LevelData['1-1']


addcoins = ->
	love.coins += 1
	if love.coins < 100
		play'assets/supermario/コイン.ogg'
	else
		play'assets/supermario/1UP.ogg'
		love.lives += 1
		love.coins -= 100

class Sprite -- チップの配列(に見えるもの)
	new: (@array)=>
		@ox, @oy, @z, @time, @freq = 0, 0, 0, 0, 0.5
		@update(0) -- 最初のスプライトやox oyを定める
	update: (dt)=> -- 等速運動する敵は時間でパタパタアニメする。(が、Playerは移動距離によってパタパタアニメする)
		@time += dt
		n = idiv(@time, @freq) % #@array + 1
		for k, v in pairs @array[n] do @[k] = v -- [1]などのほかoxやfreqももしあればコピーされるので最初の配列にいろいろ入れておく。
		@[#@array[n]+1] = nil
	@flips = {[1]: {-1,1,16,0}, [3]: {}, [-1]: {-1,-1,16,16}, [-3]: {1,-1,0,16}} -- 1: 左向き 3: 右向き、-1, -3 は上下反転とする

-- インスタンスとworldへ登録したものの２つを管理する。(y=257を消去フラグとする(ループ中の消去は出来ないので))
class _Charactor
	new: (@x, @y, @w, @h, @sprites)=> -- charactorはすべて画面上の座標
		@direction, @dx, @dy, @time = 3, 0, 0, 0 -- direction:{left:1 up:2 right:3 down:4} spritesは縦長の場合２つ使うため velocity→dx,dyそれぞれ別に扱われるので
		@gravity = 0.3--0.35
		@speed = 0.5
		@bounce = 0 -- 着地時跳ねる
		Scene.current.charactors[] = @
		@tweens = {}
		@collisionfilter = (_other)=> nil
		-- [注意] bump.luaに登録しない(がwalkはある)

	intersect: (other)=>  other.x < @x+@w and @x < other.x+other.w and other.y < @y+@h and @y < other.y+other.h

	warp: (x, y, w = @w, h = @h)=> @x, @y, @w, @h, _ = x, y, w, h, Scene.current.world\update(@, x, y, w, h) -- updateを使うのは例外的であるべきだが、増えてきた。

	update: (dt)=>
		@time += dt
		@tweens = [t for t in *@tweens when not t\update(dt)] -- tween完了したら削除される -- HTML5版では必ず@tweens[1]を扱う前に#@tweens > 0とチェックしなければならない。なぜ？
		@sprites\update?(dt)
		unless @.__class in {PlatformBlock, Coin} -- optimize: HTML5版で60FPS出すため調べないものを作る(動かないものは能動的には調べず、動くものから受動的に調べられる。)
			@walk(dt)
			@checkCollision()

	walk: (dt)=>

	_move_no_warp: => -- Liftと壁などに挟まれた時、大きくワープする。その対策。
		x, y, cols = Scene.current.world\move(@, @x+@dx, @y+@dy, @collisionfilter)
		if math.abs(x-@x) > math.abs(@dx)+3 or math.abs(y-@y) > math.abs(@dy)+3 -- この時ワープしたとみなし、無効とする。(それでもすり抜けるものもある)
			dy = if #Scene.current.world\queryRect(@x, @y+@h, 14, 1, (c)-> issubclass(c.__class, _Block) and not issubclass(c.__class, HiddenBlock)) > 0 then 0 else @dy
			x, y, cols, _, @dx, @dy = @x + 1, @y + dy, {}, Scene.current.world\update(@, @x + 1, @y + dy), 0, 0
		x, y, cols

	checkCollision: =>
		@x += @dx
		@y += @dy

	消滅: => @y, _ = 257, Scene.current.world?\update(@, @x, 257)
	反対方向を向く: => @direction = rawget({3, nil, 1}, @direction) -- 壁でもモンスター同士でも当たったら反対方向を向く
	着地: (_other)=> @dy = @bounce -- 地面に触れてなければ常に落ちてる。地面に触れた時飛び上がる(跳ねないときは0クリアになる)

	registerSprite: (map)=> -- 縦長までは対応、他は専用のものを書く
		ox, oy = @sprites.ox or 0, @sprites.oy or 0
		sprites = if @direction > 0 then @sprites else [c for _, c in lume.ripairs @sprites]
		for j=1,#sprites
			map.spritebatch\add(map.quads[sprites[j]], lume.round(ox+@x), lume.round(oy+@y+(j-1)*16), 0, unpack Sprite.flips[@direction])

class _Tooltip extends _Charactor
	new: (x, y, w, h, sprites, duration, dy)=>
		super(x, y, w, h, sprites)
		@sprites.z = math.huge
		@tweens[] = with tween.new(duration, @, {y: @y+dy})
			.onfinish = => @subject.y = 257

class ScoreTooltip extends _Tooltip
	@Sprites = {[100]: {0x1f1}, [200]: {0x1f2}, [400]: {0x1f3}, [800]: {0x1f4}, [1000]: {0x1f5}, [2000]: {0x1f6}, [4000]: {0x1f7}, [8000]: {0x1f8}, ['1UP']: {0x1ff} }
	new: (x, y, value)=> super(x, y-16, 16, 16, @@Sprites[value], 0.5, -36)

class CoinTooltip extends _Tooltip
	new: (x, y)=>
		super(x, y, 16, 16, {0x10b}, 0.5, -26)
	update: (dt)=>
		if #@tweens > 0 and @tweens[1].clock > 0.3 then @sprites = {0x1f2}
		super(dt)

class FallingTooltip extends _Charactor -- 重力によって落ちる。死体
	new: (charactor)=>
		super(charactor.x, charactor.y, charactor.w, charactor.h, charactor.sprites)
		@direction = -charactor.direction -- 上下反転表示
		@dx, @dy = charactor.dx, -3

	update: (dt)=>
		@dy += @gravity *dt*60
		@x, @y = @x + @dx, @y + @dy

class _Item extends _Charactor -- Coin スーパーキノコ スター
	new: (x, y, w, h, sprites)=>
		super(x, y, w, h, sprites)
		@collisionfilter = (other)=>
			if @y > 256 or issubclass(other.__class, _Enemy) or issubclass(other.__class, _Bullet) or issubclass(other.__class, _Item) or issubclass(other.__class, HiddenBlock) then nil
			elseif issubclass(other.__class, _Player) then 'cross'
			elseif issubclass(other.__class, Lift) and not (@dy >= 0 and @y+@h < other.y+0.9) then nil -- +0.9は微妙なepsilonこれがないとすり抜ける。
			else 'slide' -- 他のBlock

	walk: (dt)=>
		@dx = rawget({-@speed, nil, @speed}, @direction) * 60*dt
		@dy += @gravity * 60*dt

	checkCollision: =>
		@x, @y, cols = @_move_no_warp()
		for col in *cols
			if issubclass(col.other.__class, _Player) then @Playerにぶつかった(col.other) --, col.other[@__class.__name .. 'を取る'](col.other, @)
			-- elseif issubclass(col.other.__class, _Bullet) then _, _ = @弾に着弾(), col.other\被弾(@)
			-- elseif issubclass(col.other.__class, _Enemy) then print 'Item x Enemy'-- _, _ = @着弾(), col.other\被弾(@)
			elseif issubclass(col.other.__class, _Block)
				if col.normal.x in {-1, 1} then @壁にぶつかった()
				if col.normal.y == -1 then @着地(col.other) -- 地面に触れてなければ常に落ちてる。

	壁にぶつかった: => @反対方向を向く()
	着地: (block)=>
		super()
		if #block.tweens > 0
			@dy = -3.6 -- 跳ねる
			if (@direction == 3 and @x < block.x-4) or (direction == 1 and @x+12 > block.x) then @反対方向を向く()

class _Bullet extends _Charactor -- 蹴られた甲羅 ファイアボール
	new: (x, y, w, h, sprites)=>
		super(x, y, w, h, sprites)
		@連 = 0
		-- まだbumpに登録しない
		@collisionfilter = (other)=>
			if @y > 256 or issubclass(other.__class, _Item) or issubclass(other.__class, HiddenBlock) or other.__class == バブル or other.__class == ファイアバー  or other.__class == クッパの炎 then nil -- ファイアバー、バブル、クッパの炎とはお互いに当たり判定を持たない。
			elseif issubclass(other.__class, _Enemy) or issubclass(other.__class, _Player) then 'cross'
			elseif issubclass(other.__class, Lift) and not (@dy >= 0 and @y+@h < other.y+0.9) then nil -- +0.9は微妙なepsilonこれがないとすり抜ける。
			else 'slide' -- 他のBlock
	
	walk: (dt)=>
		@dx = rawget({-@speed, nil, @speed}, @direction) * 60*dt
		@dy += @gravity * 60*dt

	checkCollision: =>
		@x, @y, cols = @_move_no_warp()
		for col in *cols
			-- if issubclass(col.other.__class, _Player) and ((col.other.x < @x and col.move.x < 0) or (col.other.x > @x and col.move.x > 0)) then col.other\ダメージを受ける(@) -- 体から離れてゆくものからはダメージを受けないことにした→生成から0.1秒は無視することにした
			if issubclass(col.other.__class, _Player) then col.other\ダメージを受ける(@) -- 体から離れてゆくものからはダメージを受けないことにした
			elseif issubclass(col.other.__class, _Bullet) then _, _ = @弾に着弾(), lume.noop()--col.other\被弾(@)
			elseif issubclass(col.other.__class, _Enemy) then _, _ = @着弾(), col.other\被弾(@)
			elseif issubclass(col.other.__class, _Block)
				if col.normal.x in {-1, 1} then @壁にぶつかった()
				if col.normal.y == -1 then @着地(col.other) -- 地面に触れてなければ常に落ちてる。地面に触れた時飛び上がる。

	着弾: => @消滅()
	弾に着弾: => @消滅()
	壁にぶつかった: => @消滅()

class _Enemy extends _Charactor -- クリボー ノコノコ 甲羅
	new: (x, y, w, h, sprites)=>
		super(x, y, w, h, sprites)
		@direction = 1
		-- @bounce = 0
		@collisionfilter = (other)=>
			if @y > 256 or issubclass(other.__class, _Block) or issubclass(other.__class, _Enemy) or issubclass(other.__class, _Item) then nil
			-- elseif @.__class == バブル or @.__class == ファイアバー or @.__class クッパの炎 and issubclass(other.__class, _Bullet) then nil
			else 'cross'--[['slide']] -- 壁も敵も無視
		-- まだbumpに登録しない
	
	walk: (dt)=>
		@dx = rawget({-@speed, nil, @speed, [-1]: -@speed, [-3]: @speed}, @direction) * 60*dt
		@dy += @gravity * 60*dt

	checkCollision: =>
		@x, @y, cols = @_move_no_warp() -- ワープ対策は本当はGroundEnemyだけで良い。
		for col in *cols
			if issubclass(col.other.__class, _Player)
				if col.other.スター時間 > 0 then @被弾(col.other)
				else @Playerにぶつかった(col.other) -- col.other\敵にぶつかった(@)
			elseif issubclass(col.other.__class, _Bullet) then _, _ = @被弾(col.other), col.other\着弾(@)
			elseif issubclass(col.other.__class, _Enemy) and col.normal.x in {-1, 1} then _, _ = @敵にぶつかった(), col.other\敵にぶつかった(@) -- 敵同士(横のみ) -- _GroundEnemyに付けるべき
			elseif issubclass(col.other.__class, _Block)
				if col.normal.x in {-1, 1} then @壁にぶつかった()
				if col.normal.y == -1 then @着地(col.other)

	@Scores = {100, 200, 400, 1000, 2000, 4000, 8000, <index>: => '1UP'}
	被弾: (bullet)=>
		play'assets/supermario/轢く.ogg'
		bullet.連 += 1
		n = @@Scores[bullet.連]
		if n != '1UP' then love.score += n else love.lives, _ = love.lives+1, play'assets/supermario/1UP.ogg'
		ScoreTooltip(@x, @y-10, n)
		FallingTooltip(@)
		@消滅()

	-- ワープ対策を抜けてくるものがあるので、実際にrectが重なっているか調べる(Playerと敵だけ)。
	Playerにぶつかった: (player)=> if @intersect(player) then player\ダメージを受ける(@)

class _GroundEnemy extends _Enemy
	new: (x, y, w, h, sprites)=>
		super(x, y, w, h, sprites)
		-- @bounce = 0
		@collisionfilter = (other)=>
			if issubclass(other.__class, _GroundEnemy) then 'slide'
			elseif @y > 256 or issubclass(other.__class, _Enemy) or issubclass(other.__class, _Item) or issubclass(other.__class, HiddenBlock) then nil
			elseif issubclass(other.__class, Lift) and not (@dy >= 0 and @y+16--[[@h]] < other.y+1.0) then nil -- +0.9は微妙なepsilonこれがないとすり抜ける。
			elseif issubclass(other.__class, _Player) then 'cross'
			else 'slide' -- 他のBlock
		-- まだbumpに登録しない
	
	敵にぶつかった: _Enemy.__base.反対方向を向く
	壁にぶつかった: _Enemy.__base.反対方向を向く
	着地: (block)=>
		super()
		if #block.tweens > 0 then @被弾(Scene.current.player) -- ブロックを通して頭突きで倒された

class _Block extends _Charactor
	new: (x, y, w, h, sprites)=> -- w = 16, @h = 14
		if y == 16*12+8 then sprites, h = [sprites[1] for _=1,4], 16*4-2 -- optimize: オブジェクト数を少なくするため、床ブロックは縦４行をまとめる
		super(x, y, w, h, sprites)
		Scene.current.world\add(@, @x, @y, @w, @h)

	Playerにぶつかった: (player)=> play'assets/supermario/頭ぶつける.ogg' -- 動かないブロック

	shake: =>
		@tweens[] = with tween.new(0.2, @, {y: @y})
			@y -= 2

class BlickBlock extends _Block -- レンガ
	new: (x, y)=> super(x, y, 16, 14, {0x41+Scene.current.sprites_offset})

	Playerにぶつかった: (player)=>
		@shake()
		if player.__class == チビマリオ then play'assets/supermario/頭ぶつける.ogg'
		else @update, _ = coroutine.wrap(@_update2), play'assets/supermario/ブロック破壊.ogg'

	_update2: =>
		for i=1, 2 do _, _ = coroutine.yield() -- 頭突きを伝播させるために消滅を遅らせる。
		with FallingTooltip(@)
			.x, .y, .sprites, .direction, .dx, .dy = @x+12, @y+8-12, {0x11f}, 3, 1.3, -3.0 -- 大幅書き換えで４つの瓦礫にする。
		with FallingTooltip(@)
			.x, .y, .sprites, .direction, .dx, .dy = @x+12, @y-12, {0x11f}, -3, 1.3, -6.0
		with FallingTooltip(@)
			.x, .y, .sprites, .direction, .dx, .dy = @x-4, @y+8-12, {0x11f}, 1, -1.3, -3.0
		with FallingTooltip(@)
			.x, .y, .sprites, .direction, .dx, .dy = @x-4, @y-12, {0x11f}, -1, -1.3, -6.0
		@消滅()
		@update = nil


class ItemBlock extends _Block
	new: (x, y, sprites, @Item)=>
		super(x, y, 16, 14, sprites)
		-- @sprites.time = love.timer.getTime() -- 輝くアニメが揃うようにする

	update: (dt)=>
		super(dt)
		if @sprites.time then @sprites.time = love.timer.getTime() -- 輝くアニメが揃うようにする(スタートを合わせただけだとダメ。なぜ？)

	Playerにぶつかった: (player)=>
		@.Item(@x, @y-16)
		with PlatformBlock(@x, @y, {0x45+Scene.current.sprites_offset})
			\shake()
		@消滅()

class HiddenBlock extends ItemBlock

class ManyCoinsBlock extends _Block
	new: (x, y)=> super(x, y, 16, 14, {0x41+Scene.current.sprites_offset})
	Playerにぶつかった: (player)=>
		@shake()
		@starttime or= love.timer.getTime()
		addcoins()
		love.score += 200
		CoinTooltip(@x, @y-16)
		if love.timer.getTime() - @starttime > 2.5
			with PlatformBlock(@x, @tweens[1]?.target.y or @y, {0x45+Scene.current.sprites_offset})
				\shake()
			@消滅()

class PlatformBlock extends _Block
	new: (x, y, sprites)=> super(x, y, 16, 14, sprites)

class 砲台 extends _Block
	@Freq = 5.0
	new: (x, y)=> super(x, y, 16, 14, {0x4f, z: 2})

	update: (dt)=>
		super(dt)
		if @time > @@Freq then
			@time -= @@Freq
			play'assets/supermario/キラー発射.ogg'
			if @x > Scene.current.player.x then キラー(@x-3, @y, 1) else キラー(@x+3, @y, 3)

class Lift extends _Block
	@W = 32 -- ステージごとに変える？
	new: (x, y, speed)=> -- speed 上下方向も表す。
		super(x, y, @@W, 8, {0x113, z: 1})
		@speed = speed

	update: (dt)=>
		@y += @speed * 60*dt
		if @y < -16 then @y += 256+16
		if @y > 256 then @y -= 256-16
		Scene.current.world\update(@, @x, @y, @@W, 8)
		-- for item in *Scene.current.world\queryRect(@x, @y-1, @@W, 1, (c)-> issubclass(c.__class, _Player) or issubclass(c.__class, _Item) or issubclass(c.__class, _GroundEnemy) or issubclass(c.__class, _Bullet)) -- 上にPlayerなどが乗っていたら一緒に動かす [spec] コインが持っていかれる
		for item in *Scene.current.world\queryRect(@x, @y-1, @@W, 1, (c)-> issubclass(c.__class, _GroundEnemy) or not issubclass(c.__class, _Enemy)) -- 上にPlayerなどが乗っていたら一緒に動かす [spec] コインが持っていかれる
			item\warp(item.x, @y-item.h)

	registerSprite: (map)=> for i = 0, @@W-8, 8 do map.spritebatch\add(map.quads[@sprites[1]], lume.round(@x+i), lume.round(@y))

class 雲ブロック extends _Block
	@W = 48
	new: (x, y, speed)=>
		super(x, y, @@W, 8, {0x11b, z: 3})
		@speed = 0

	update: (dt)=>
		@x += @speed * 60*dt
		Scene.current.world\update(@, @x, @y, @@W, 8)
		if #Scene.current.world\queryRect(@x, @y-1, @@W, 1, (c)-> issubclass(c.__class, _Player)) > 0 -- 上にPlayerが乗っていたら一緒に動かす
			@speed = 0.5 -- 乗ったらスタート
			Scene.current.player.x, Scene.current.player.y, _ = Scene.current.world\move(Scene.current.player, Scene.current.player.x + @speed * 60*dt, Scene.current.player.y, Scene.current.player.collisionfilter)

	registerSprite: Lift.__base.registerSprite

class Coin extends _Item
	new: (x, y)=>
		super(x+2, y+2, 12, 12, Sprite({{0x10a, ox: -2, oy: -2, }, {0x1e2}, {0x1e3}, {0x1e2}}) )
		@sprites.time = love.timer.getTime() -- 輝くアニメが揃うようにする
		Scene.current.world\add(@, @x, @y, @w, @h)

	walk: => -- 動かない
	Playerにぶつかった: (_player)=> _, love.score, _ = addcoins(), love.score+200, @消滅()

class スーパーキノコ extends _Item
	@Sprites = {0x10c, ox: -1, z: -1}
	new: (x, y)=>
		super(x+1, y, 14, 16, @@Sprites)
		@speed = 0.8
		Scene.current.world\add(@, @x, @y, @w, @h)
		play'assets/supermario/アイテム出現.ogg'
		@sprites.oy, @update = 14, @updateせり上がる -- 実体はブロックの上にあるが、描画だけせり上がる

	updateせり上がる: (dt)=>
		@time += dt
		@sprites.oy = 14 - 14 * @time / 0.7
		if @sprites.oy <= 0 then @sprites.oy, @update = 0, nil

	Playerにぶつかった: (player)=> _, _ = player\powerUp(@), @消滅()

class ファイアフラワー extends スーパーキノコ -- 素朴に_Itemから継承したほうが読みやすいかも
	@Sprites = {0x10e, ox: -1, z: -1}
	new: (x, y)=>
		super(x, y)
		@speed = 0

class １ＵＰキノコ extends スーパーキノコ
	@Sprites = {0x10d, ox: -1, z: -1}

	Playerにぶつかった: (_player)=> love.lives, _, _, _ = love.lives+1, ScoreTooltip(@x, @y, '1UP'), @消滅(), play'assets/supermario/1UP.ogg'

class スター extends スーパーキノコ
	@Sprites = {0x10f, ox: -1, z: -1}
	new: (x, y)=>
		super(x, y)
		@bounce = -6.0

	Playerにぶつかった: (player)=> _, _ = player\スター(@), @消滅()

class ファイアボール extends _Bullet
	new: (x, y, direction)=>
		super(rawget({x-8+2, nil, x+16-2}, direction), y+16+2--[[+3]], 4, 4, {0x115, ox: -2})
		@direction, @gravity, @speed, @bounce = direction, 0.2, _Player.SpeedB, -2.0
		Scene.current.world\add(@, @x, @y, @w, @h)
		play'assets/supermario/ファイアボール.ogg'

	壁にぶつかった: =>
		play'assets/supermario/頭ぶつける.ogg'
		_Tooltip(@x, @y, 16, 16, {0x117}, 0.1, 0)
		@消滅()

class クリボー extends _GroundEnemy
	new: (x, y)=>
		super(x+1, y, 14, 16, Sprite({{0x111, ox: -1}, {0x112}}))
		Scene.current.world\add(@, @x, @y, @w, @h)

	Playerにぶつかった: (player)=>
		if player.y + player.h < @y+@h -- 踏まれた baselineで比較
			player\踏んで少し跳ねる()
			player.連 += 1
			n = @@Scores[player.連]
			if n != '1UP' then love.score += n else love.lives, _ = love.lives+1, play'assets/supermario/1UP.ogg'
			ScoreTooltip(@x, @y-10, n)
			_Tooltip(@x, @y, 16, 16, {0x110, z: -1}, 1.0, 0) -- 残骸
			@消滅()
		else super(player)

class ノコノコ extends _GroundEnemy -- スプライトは縦長だが当たり判定はクリボーと同じとする。
	@Sprites = {{0x142, 0x152, ox: -1, oy: -16}, {0x143, 0x153}}
	new: (x, y)=>
		super(x, y, 14, 16, Sprite(@@Sprites))--{{0x142, 0x152, ox: -1, oy: -16}, {0x143, 0x153}}))
		Scene.current.world\add(@, @x, @y, @w, @h)

	Playerにぶつかった: (player)=>
		if @time < 3/60 --[[0.1]] then return -- パタパタから変化した時すぐに甲羅にならないように
		if player.y + player.h < @y+@h -- 踏まれた baselineで比較
			player\踏んで少し跳ねる()
			甲羅(@x, @y, @.__class)
			love.score, _ = love.score+100, ScoreTooltip(@x, @y, 100)
			@消滅()
		else super(player)

class パタパタ extends ノコノコ
	@Sprites = {{0x144, 0x154, ox: -1, oy: -16}, {0x145, 0x155}}
	new: (x, y)=>
		super(x, y)
		@bounce = -6.0
	
	Playerにぶつかった: (player)=>
		if player.y + player.h < @y+@h -- 踏まれた baselineで比較
			player\踏んで少し跳ねる()
			ノコノコ(@x, @y)
			love.score, _ = love.score+400, ScoreTooltip(@x, @y, 400)
			@消滅()
		else super(player)

class メット extends ノコノコ--_GroundEnemy
	@Sprites = {{0x162, ox: -1}, {0x163}}

	被弾: (bullet)=> if bullet.__class == ファイアボール then bullet\壁にぶつかった() else super(bullet)

class 甲羅 extends _GroundEnemy
	new: (x, y, @Prev)=>
		if @Prev.__class == ノコノコ
			@@Sprites = {{0x150, ox: -1, oy: -1}, ['前兆']: {0x151, ox: -1, oy: -1} }
		else -- メット
			@@Sprites = {{0x160, ox: -1, oy: -1}, ['前兆']: {0x161, ox: -1, oy: -1} }
		super(x, y, 14, 15, @@Sprites[1])
		@speed = 0
		Scene.current.world\add(@, @x, @y, @w, @h)
		@被弾 = @Prev.__base.被弾

	update: (dt)=> -- 時間でノコノコ(メット)に戻る
		super(dt)
		@sprites = if (3.0 < @time and @time < 3.2) or (3.4 < @time and @time < 3.6) or (3.8 < @time and @time < 4.0) then @@Sprites['前兆'] else @@Sprites[1]
		if 4.2 < @time
			@.Prev(@x, @y)
			@消滅()

	Playerにぶつかった: (player)=> -- 蹴る
		if @time < 3.5/60 then return -- 作られてすぐは無視する(dtには誤差があるのでn frames無視するなら.5を付ける)
		play'assets/supermario/轢く.ogg'
		蹴られた甲羅(@x, @y, (if Scene.current.player.x > @x then 1 else 3), @Prev)
		player.連 += 1
		n = @@Scores[player.連]
		if n != '1UP' then love.score += n else love.lives, _ = love.lives+1, play'assets/supermario/1UP.ogg'
		ScoreTooltip(@x, @y-10, n)
		@消滅()

class 蹴られた甲羅 extends _Bullet
	new: (x, y, direction, @Prev)=>
		super(x, y, 14, 15, if @Prev == ノコノコ then {0x150, ox: -1, oy: -1} else {0x160, ox: -1, oy: -1})
		@speed, @direction, @連 = _Player.SpeedB, direction, 1
		Scene.current.world\add(@, @x, @y, @w, @h)
		@被弾 = @Prev.__base.被弾
	着弾: => -- 貫通する

	壁にぶつかった: =>
		-- print '甲羅が壁にぶつかった。', @time*60
		@反対方向を向く()
		play'assets/supermario/頭ぶつける.ogg'

	踏んで止められた: (player)=>
		player\踏んで少し跳ねる()
		甲羅(@x, @y, @Prev)
		@消滅()

class ジュゲム extends _Enemy
	new: (x, y)=>
		super(x, y, 16, 16, {0x146, 0x156, oy: -16, z: 1})
		@cx, @speed, @gravity = @x, 0, 0
		Scene.current.world\add(@, @x, @y, @w, @h)

	walk: (dt)=>
		@cx = lume.lerp(@cx, Scene.current.player.x + 64, 0.001)
		@x = @cx + math.sin(@time) * 100

	update: (dt)=>
		super(dt)
		if @time > 6 then @time, _ = @time-6, 落下中トゲゾー(@x, @y-16)
	
	Playerにぶつかった: (player)=> -- 踏んで倒す
		if player.y + player.h < @y+@h -- 踏まれた baselineで比較
			player\踏んで少し跳ねる()
			player.連 += 1
			n = @@Scores[player.連]
			if n != '1UP' then love.score += n else love.lives, _ = love.lives+1, play'assets/supermario/1UP.ogg'
			ScoreTooltip(@x, @y-10, n)
			FallingTooltip(@)
			@消滅()
		else super(player)

class 落下中トゲゾー extends _GroundEnemy
	new: (x, y)=>
		super(x, y, 14, 16, {0x118, ox: -1})
		Scene.current.world\add(@, @x, @y, @w, @h)
		@dy = -3

	着地: (_other)=> トゲゾー(@x, @y, if Scene.current.player.x < @x then 1 else 3) |> @消滅() -- playerの方に向かう？

class トゲゾー extends _GroundEnemy
	new: (x, y, direction)=>
		super(x, y, 14, 12, Sprite({{0x119, ox: -1, oy: -4}, {0x11a}}))
		@direction = direction
		Scene.current.world\add(@, @x, @y, @w, @h)

class キラー extends _Enemy
	new: (x, y, direction = 1)=>
		super(x, y+1, 16, 14, {0x114, z: 1}) -- ブロックが14なので合わせる
		@direction, @speed, @gravity = direction, 1.0, 0
		Scene.current.world\add(@, @x, @y, @w, @h)
	Playerにぶつかった: ジュゲム.__base.Playerにぶつかった
	被弾: メット.__base.被弾

class バブル extends _Enemy
	new: (x, y)=>
		super(x, 256, 14, 14, Sprite({{0x116, ox: -1, oy: -1, z: 1}})) -- 一番上の段に配置しておくと下から出現
		@speed, @gravity = 0, 0.05
		Scene.current.world\add(@, @x, @y, @w, @h)
		@setup()
		@collisionfilter = (other)=> if @y > 256 or issubclass(other.__class, _Block) or issubclass(other.__class, _Enemy) or issubclass(other.__class, _Item) or issubclass(other.__class, _Bullet) then nil else 'cross'

	setup: => @dy, @direction, _ , @time, @update = -4, 1, @warp(@x, 256), 0, coroutine.wrap(@_update待ち) -- [bug] [spec] sprite.oyがあるのでy=256は完全な画面外ではない。

	_update待ち: (dt)=>
		while @time < 2.5
			@time += dt
			_, dt = coroutine.yield()
		@update = nil

	checkCollision: =>
		super()
		if @dy > 0 then @direction = -1
		if @y > 256 then @setup()
	被弾: =>
	
class ファイアバー extends _Enemy -- の炎１つ
	new: (@cx, @cy, @r, speed)=>
		super(@cx-4+@r, @cy-4, 8, 8, Sprite({{0x115, z: 1}}))
		@speed = speed
		@direction, @gravity, @dx, @dy = 3, 0, 0, 0 -- directionはspritesの反転に使われるので反転しないように
		Scene.current.world\add(@, @x, @y, @w, @h)
		@collisionfilter = (other)=> if @y > 256 or issubclass(other.__class, _Block) or issubclass(other.__class, _Enemy) or issubclass(other.__class, _Item) or issubclass(other.__class, _Bullet) then nil else 'cross'

	walk: (dt)=> @x, @y = @cx+@r*math.sin(@time*@speed)-4, @cy+@r*math.cos(@time*@speed)-4
	被弾: =>

class クッパの炎 extends _Enemy
	new: (x, y)=>
		play'assets/supermario/クッパの炎.ogg'
		super(x, y, 24, 8, Sprite({{0x164, 0x165, ox: -4}, {0x166, 0x167}}))
		@speed, @gravity = 1, 0
		Scene.current.world\add(@, @x, @y, @w, @h)
		@collisionfilter = (other)=> if @y > 256 or issubclass(other.__class, _Block) or issubclass(other.__class, _Enemy) or issubclass(other.__class, _Item) or issubclass(other.__class, _Bullet) then nil else 'cross'
	被弾: =>

	registerSprite: (map)=>
		ox, oy = @sprites.ox or 0, @sprites.oy or 0
		sprites, flip = if @direction == 1 then {@sprites[2], @sprites[1]}, {-1, 1, 16, 0} else @sprites, {}
		for i, id in ipairs sprites
			map.spritebatch\add(map.quads[id], lume.round(ox+@x+(i-1)*16*lume.sign(@direction)), lume.round(oy+@y), 0, unpack flip) -- 1: 左向き 3: 右向き

class プクプク extends _Enemy
	new: (x, y, direction = 1)=>
		super(x, 256, 16, 16, Sprite({{0x11c, z: 1}, {0x11d}}))
		@direction, @gravity = direction, 0.03
		Scene.current.world\add(@, @x, @y, @w, @h)
		@dy = -4
	Playerにぶつかった: ジュゲム.__base.Playerにぶつかった

class ゲッソー extends _Enemy
	new: (x, y)=>
		super(x+1, y+8, 14, 16, Sprite({{0x14a, 0x15a, ox: -1, oy: -8, z: 1}, {0x14b, 0x15b}}))
		@gravity, @sprites.freq, @speed = 0, 0.8, 0
		Scene.current.world\add(@, @x, @y, @w, @h)

	update: (dt)=>
		super(dt)
		if @time > @sprites.freq*2 then @time, @direction = @time-@sprites.freq*2, if Scene.current.player.x < @x then 1 else 3
		if @time % (@sprites.freq*2) < @sprites.freq then @dy, @speed = -0.4, 1
		else @dy, @speed = 0.4, 0
	Playerにぶつかった: ジュゲム.__base.Playerにぶつかった

class パックンフラワー extends _Enemy
	new: (x, y)=> -- 土管の左上に配置しておくと、土管の中(少し右下)に生成される。
		super(x+8+2, y+16+10, 12, 22, Sprite({{0x148, 0x158, ox: -2, oy: -10, z: -1}, {0x149, 0x159}}))
		@speed, @gravity = 0, 0
		Scene.current.world\add(@, @x, @y, @w, @h)
		@tweens[] = with tween.new(2.0, @, {y: @y-32})
			.onfinish = => @scale *= -1
	
	update: (dt)=>
		if #@tweens > 0 and @tweens[1].clock < 0.3 and @x-8-14-10 < Scene.current.player.x and Scene.current.player.x < @x+24+10 -- 8 or 24 土管の縁まで 14 Playerの幅 10 余裕
			@tweens[1].clock = 0 -- playerが近くにいたら出てこない
		super(dt)

class ハンマーブロス extends _GroundEnemy
	new: (x, y)=>
		super(x+1, y+10, 14, 22, Sprite({{0x14c, 0x15c, ox: -2, oy: -8-2, z: 1}, {0x14c, 0x15d}}))
		@cx, @speed, @time2, @schedule = @x, 0, 0, {false, false, false, true, true, true}
		Scene.current.world\add(@, @x, @y, @w, @h)
	
	update: (dt)=>
		super(dt)
		@x = @cx + math.sin(@time*2)*8
		@time2 += dt
		if @time2 > 1.1
			@time2, _ = @time2-1.1, table.insert(@schedule, table.remove(@schedule, 1)) -- 配列をrotateする
			if @schedule[#@schedule] then ハンマー(@x+6, @y-15, @)
		@direction = if Scene.current.player.x < @x then 1 else 3
	Playerにぶつかった: ジュゲム.__base.Playerにぶつかった

class ハンマー extends _Enemy
	new: (x, y, @owner)=>
		super(x, y, 8, 8, Sprite({{0x11e, ox: -4, oy: -4, z: 1, freq: 0.15}, {0x1ed}, {0x1ee}, {0x1ef} }))
		Scene.current.world\add(@, @x, @y, @w, @h)
		@update = coroutine.wrap(@_update投げられるまで)
	
	_update投げられるまで: (dt)=>
		while @time < 0.5
			@time += dt
			if @owner.y > 256 then @消滅()
			@x, @direction = @owner.x+6, @owner.direction
			_, dt = coroutine.yield()
		@dy, @speed, @update = -4, 2.1, nil
	被弾: メット.__base.被弾

class クッパ extends _GroundEnemy
	new: (x, y)=>
		super(x, y, 32, 32, Sprite({{0x180, 0x181, 0x190, 0x191}, {0x182, 0x183, 0x192, 0x193}}))
		@hp = 5
		@speed, @gravity, @bounce, @time2 = 0.333, 0.016, -1, 0
		Scene.current.world\add(@, @x, @y, @w, @h)

	update: (dt)=>
		super(dt)
		@time2 += dt
		@direction = if Scene.current.player.x < @x then 1 else 3
		if @time > 3 then @time, _ = @time-3, クッパの炎(@x-40, @y+12)
		if @time2 > 5 then @time2, @speed = @time2-5, @speed * -1
	
	registerSprite: (map)=>
		ox, oy = @sprites.ox or 0, @sprites.oy or 0
		chips = rawget({[3]: {1,2,3,4}, [1]: {2,1,4,3}, [-3]: {3,4,1,2}, [-1]: {4,3,2,1}}, @direction)
		for j=0,1
			for i=0,1
				map.spritebatch\add(map.quads[@sprites[chips[j*2+i+1]]], lume.round(ox+@x+i*16), lume.round(oy+@y+j*16), 0, unpack Sprite.flips[@direction])

	被弾: (bullet)=>
		@hp -= 1
		if @hp <=0 then super(bullet)
		

class _Player extends _Charactor
	@Speed, @SpeedB = 1.5, 3.0
	new: (x, y, w, h, sprites)=>
		super(x+1, y+16-h, w, h, sprites)
		Scene.current.player = @
		Scene.current.world\add(@, @x, @y, @w, @h) -- 細くしないと１マスの間を通れない
		@collisionfilter = (other)=>
			if issubclass(other.__class, _Item) or issubclass(other.__class, _Enemy) or issubclass(other.__class, _Bullet) then 'cross'
			elseif issubclass(other.__class, HiddenBlock) and other.y + 14 >= @y then nil -- ブロックのサイズが１６だからって+16をすると当たらない
			elseif issubclass(other.__class, Lift) and not (@dy >= 0 and @y+@h < other.y+1.0) then nil -- +0.9は微妙なepsilonこれがないとすり抜ける。
			else 'slide' -- 他のBlock
		@スター時間 = 0
		@連 = 1 -- 連続で倒すと高得点になるしくみ
	
	walk: (dt)=>
		isBDash = input.B()-- and @dy == 0
		if @direction := (if input.Left() and not input.Down() then 1 elseif input.Right() and not input.Down() then 3 else nil) -- 下を押している時(しゃがんでいる時)は左右に移動できない
			old_dx = @dx
			@dx += rawget({-0.07, nil, 0.07}, @direction) * (if isBDash then 1.5 else 1.0) -- 加速
			@dx = if isBDash then lume.clamp(@dx, -@@SpeedB, @@SpeedB) elseif old_dx < -@@Speed or @@Speed < old_dx then old_dx * 0.9 else lume.clamp(@dx, -@@Speed, @@Speed) -- 最高速度
		else
			@dx *= 0.9 -- 減衰して…↓
			if math.abs(@dx) < 0.1 then @dx = 0 -- 止まる
		@dy += @gravity * 60*dt
		if @dy > 0 and math.abs(@dx) > @@Speed and #Scene.current.world\queryRect(@x-2, @y+@h, @w+4, 1, (c)-> issubclass(c.__class, _Block) and not issubclass(c.__class, HiddenBlock)) >= 2 then @dy = 0 -- BDash中は隙間に落ちない(Playerが隙間にいる時、足元両サイドにブロックがあるか調べている)
		if input.Ap() and #Scene.current.world\queryRect(@x, @y+@h, @w, 1, (c)-> issubclass(c.__class, _Block) and not issubclass(c.__class, HiddenBlock)) > 0
			@dy, @a_released = (if @dx > @@Speed then -7.4 else -6.8), false -- ジャンプ力は４ブロック(Bダッシュは５ブロック？)
			play if #@sprites == 1 then 'assets/supermario/ジャンプ.ogg' else 'assets/supermario/ジャンプ2.ogg'
			@連 = 1
		if input.Ar() then @dy = math.max(@dy, -2.0)

	checkCollision: =>
		@x, @y, cols = @_move_no_warp()
		for col in *cols
			if issubclass(col.other.__class, _Item) then col.other\Playerにぶつかった(@) -- 各アイテム側で行う
			elseif issubclass(col.other.__class, _Enemy)
				if @スター時間 > 0 then col.other\被弾(@)
				else col.other\Playerにぶつかった(@) -- 敵側で行う
			elseif issubclass(col.other.__class, _Bullet) then lume.noop() -- @弾にぶつかった()
			elseif issubclass(col.other.__class, _Block)
				if col.normal.y < 0 then @dy = 0 -- 着地 
				elseif col.normal.y > 0 and @dy < 0 then
					if #Scene.current.world\queryRect(col.touch.x, col.touch.y-2, @w-3.9, 2, (c)-> issubclass(c.__class, _Block)) == 0 then @warp(col.other.x-14, @y) -- ぬるっと真上のブロックに上がれる仕組み
					elseif #Scene.current.world\queryRect(col.touch.x+3.9, col.touch.y-2, @w-3.9, 2, (c)-> issubclass(c.__class, _Block)) == 0 then @warp(col.other.x+16, @y) -- 〃
					else @dy, _ = 0, col.other\Playerにぶつかった(@) -- ブロックに頭ぶつける
		if @x < -Scene.current.scroll[1] then @warp(-Scene.current.scroll[1], @y) -- 画面左端からは移動できない
		if @x > -Scene.current.scroll[1]+256-14 then @warp(-Scene.current.scroll[1]+256-14, @y) -- 一応画面右端も付けておく
		if Scene.current.time <= 0 then @死亡() -- 時間切れ

	update: (dt)=>
		@walk(dt)
		@checkCollision()
		@スター時間 -= dt
		if Scene.current.player.y > 256 and nil == rawget(Scene.current, 'update') -- @yでは消滅させたものでも反応してしまうため、常に最新のplayerで
			if warpinfo := lume.first [it for it in *Scene.current.warppoints when it[2]==257] then warpinfo.action() -- warppointsに追記で落下時になにかできる
			else @死亡()
		@sprites\update?(@dx * 0.1)

	-- 踏んで少し跳ねる: => @dy, _ = (if input.A() then -7 else -4), play'assets/supermario/stomp.ogg' -- -2.0なら無限1UPできる？
	踏んで少し跳ねる: => @dy, _ = (if input.A() then -6 else -3.5), play'assets/supermario/stomp.ogg'
		
	-- powerUp: (item)=>
	スター: =>
		@スター時間 = 8
		@連 = 1
		BGM({'assets/supermario/無敵ＢＧＭ.ogg', 'assets/supermario/maintheme_intro.ogg', 'assets/supermario/maintheme.ogg', })

	死亡: =>
		Scene.current.update = coroutine.wrap(Scene.current._update_player_died)
		with FallingTooltip(@)
			.sprites, .direction = {0x100}, 1
		@消滅()

	registerSprite: (map)=>
		@sprites = if input.Down() then @@Sprites['しゃがむ']
		elseif @dy != 0 then @@Sprites['ジャンプ'] -- elseif #(Scene.current.world\queryRect(@x, @y+@h, 14, 1)) == 0 then @@Sprites['ジャンプ'] elseif @dy < 0 or @gravity*2.01 < @dy then @@Sprites['ジャンプ']
		elseif @dx ==0 then @@Sprites['立ち姿勢']
		elseif (input.Left() and @dx > 0) or (input.Right() and @dx < 0) then @@Sprites['ブレーキ']
		else @@Sprites
		if ((@ダメージ無効時間 and @ダメージ無効時間 > 0) or @スター時間 > 0) and love.frame_count % 3 == 0 then return -- todo: スターの演出が無敵と現状同じ
		super(map)
		
class チビマリオ extends _Player
	@Sprites = Sprite{{0x102, ox: -1, ['立ち姿勢']: {0x101, ox: -1}, ['ジャンプ']: {0x106, ox: -1}, ['ブレーキ']: {0x105, ox: -1}, ['しゃがむ']: {0x101, ox: -1} }, {0x103}, {0x102}, {0x104}}
	new: (x, y)=>
		super(x, y, 14, 16, @@Sprites)
		@ダメージ無効時間 = 0

	update: (dt)=>
		@ダメージ無効時間 -= dt
		super(dt)

	powerUp: (_item)=>
		play'assets/supermario/パワーアップ.ogg'
		with スーパーマリオ(@x, @y)
			.direction, .dx, .dy, .スター時間 = @direction, @dx, @dy, @スター時間
		love.score, _ = love.score+1000, ScoreTooltip(@x, @y-16, 1000)
		@消滅()
		Scene.current.update = coroutine.wrap(Scene.current._update_powerup) -- 時間停止

	ダメージを受ける: (other)=> -- todo: refactoring 敵と弾両方になってる。
		if @ダメージ無効時間 > 0 or @スター時間 > 0 or other.time < 5.5/60 then return -- 弾が作られてすぐは無視する
		-- print other.time*60, col?.touch.y, @y, col?.move.y, other.y, @dy
		if issubclass(other.__class, 蹴られた甲羅) and (@y+@h < other.y+other.h or other.time < 6.5/60) -- 踏まれた baselineで比較 無限1UPのため、1fだけ下で触れても死なないことにした。
			other\踏んで止められた(@)
			return
		@死亡()

class スーパーマリオ extends _Player
	@Sprites = Sprite{{0x122, 0x132, ox: -1, ['立ち姿勢']: {0x121, 0x131, ox: -1}, ['ジャンプ']: {0x126, 0x136, ox: -1}, ['ブレーキ']: {0x125, 0x135, ox: -1}, ['しゃがむ']: {0x120, 0x130, ox: -1, oy: -16} }, {0x123, 0x133},  {0x122, 0x132},{0x124, 0x134}}
	new: (x, y)=> super(x, y, 14, 32, @@Sprites)
	
	update: (dt)=>
		super(dt)
		if input.Downp() then @warp(@x, @y+16, 14, 16)
		if input.Downr() then @warp(@x, @y-16, 14, 32)

	powerUp: (_item)=>
		play'assets/supermario/パワーアップ.ogg'
		with ファイアマリオ(@x, @y+16) -- 生成される時yがhにより調節されるので
			.direction, .dx, .dy, .スター時間 = @direction, @dx, @dy, @スター時間
		love.score, _ = love.score+1000, ScoreTooltip(@x, @y, 1000)
		@消滅()
		Scene.current.update = coroutine.wrap(Scene.current._update_powerup) -- 時間停止

	ダメージを受ける: (other)=>
		if @スター時間 > 0 or other.time < 5.5/60 then return -- 作られてすぐは無視する
		-- print other.time, other.time*60
		if issubclass(other.__class, 蹴られた甲羅) and (@y+@h < other.y+other.h or other.time < 6.5/60) -- 踏まれた baselineで比較
			other\踏んで止められた(@)
			return
		play'assets/supermario/土管.ogg'
		with チビマリオ(@x, @y+16)
			.direction, .dx, .dy, .ダメージ無効時間 = @direction, @dx, @dy, 3.0
		@消滅()

class ファイアマリオ extends スーパーマリオ
	@Sprites = Sprite{{0x12a, 0x13a, ox: -1, ['立ち姿勢']: {0x129, 0x139, ox: -1}, ['ジャンプ']: {0x12e, 0x13e, ox: -1}, ['ブレーキ']: {0x12d, 0x13d, ox: -1}, ['しゃがむ']: {0x128, 0x138, ox: -1, oy: -16} }, {0x12b, 0x13b}, {0x12a, 0x13a}, {0x12c, 0x13c}}
	-- new: (x, y)=> super(x, y, 14, 32, @@Sprites)
	update: (dt)=>
		super(dt)
		if input.Bp() and lume.count(Scene.current.charactors, (c)-> c.__class == ファイアボール) < 3 then ファイアボール(@x, @y, @direction) -- ３個までにする

	powerUp: (_item)=> love.score, _ = love.score+1000, ScoreTooltip(@x, @y, 1000)


Scene.letters = Map('assets/supermario/bg8x8.png', {8, 8}) -- ベースクラスを外から改造できてしまう

macro C = (c)-> "#{utf8.codepoint(c)}" -- 文字コードにする

class Field extends Scene
	new: (@level, @Player = チビマリオ, @old_player_x = 0)=>
		super()
		@bg_spr = Map('assets/supermario/bg_spr_16x16.png', {16, 16})
		@scroll = {0, 0}
		@world = bump.newWorld(256)
		@charactors, @schedule = {}, {}
		-- @泡time = 0

	attach: =>
		Scene.current = @ -- 重ねない
		{bgcolor: @bgcolor, sprites_offset: @sprites_offset = 0, time: @time, startpoints: startpoints, field: _field, bgm: @bgm, warppoints: @warppoints = {}, goal_x: @goal_x = math.huge } = LevelData[@level]
		@field = [lume.clone(row) for row in *_field] -- _fieldを変更するのでdeepcopyしておく
		for y, row in ipairs @field -- fieldデータ内でオブジェクトを表すものを取り除いてscheduleに溜める
			for x, cell in ipairs row
				ix, iy = (x-1)*16, (y-1)*16+8
				if f := switch cell
						when $C(A) then -> BlickBlock(ix, iy) -- 崩れるレンガブロック
						when $C(q) then -> ManyCoinsBlock(ix, iy)
						when $C(r) then -> ItemBlock(ix, iy, {0x41+@sprites_offset}, １ＵＰキノコ)
						-- when $C(s) then -> ItemBlock(ix, iy, {0x41+@sprites_offset}, '蔦')
						when $C(t) then -> ItemBlock(ix, iy, {0x41+@sprites_offset}, スター)
						when $C(u) then -> ItemBlock(ix, iy, Sprite({{0x43}, {0x1e0}, {0x1e1}, {0x1e0}}), (x, y)-> _, love.score, _ = addcoins(), love.score+200, CoinTooltip(x, y))
						when $C(v) then -> ItemBlock(ix, iy, Sprite({{0x43}, {0x1e0}, {0x1e1}, {0x1e0}}), (x, y)-> if @player.__class == チビマリオ then スーパーキノコ(x, y) else ファイアフラワー(x, y))
						-- when $C(w) then -> ItemBlock(ix, iy, {0x43+@sprites_offset}, 'coin')
						-- when $C(x) then -> ItemBlock(ix, iy, {0x43+@sprites_offset}, 'coin')
						when $C(y) then -> HiddenBlock(ix, iy, {0x40+@sprites_offset}, (x, y)-> _, love.score, _ = addcoins(), love.score+200, CoinTooltip(x ,y)) -- 隠しコインブロック
						when $C(z) then -> HiddenBlock(ix, iy, {0x40+@sprites_offset}, １ＵＰキノコ) -- 隠し１UPキノコ
						when $C(ｺ) then -> Coin(ix, iy)
						when $C(ｸ) then -> クリボー(ix, iy)
						when $C(ﾉ) then -> ノコノコ(ix, iy)
						when $C(ﾇ) then -> パタパタ(ix, iy)
						when $C(ｷ) then -> キラー(ix, iy)
						when $C(ﾄ) then -> トゲゾー(ix, iy)
						when $C(ﾌ) then -> プクプク(ix, iy)
						when $C(ﾊ) then -> パックンフラワー(ix, iy)
						when $C(ｼ) then -> ジュゲム(ix, iy)
						when $C(ﾙ) then -> バブル(ix, iy)
						when $C(ﾒ) then -> メット(ix, iy)
						when $C(ｰ) then ->
							PlatformBlock(ix, iy, {0x45})
							for r=0,10*5,10 do ファイアバー(ix+8, iy+8, r, 1.0)
						when $C(ﾘ) then -> Lift(ix, iy, -0.4)
						when $C(ﾓ) then -> 雲ブロック(ix, iy, 0.4)
						-- when $C(ﾎ) then -> クッパの炎(ix, iy, 0.4)
						when $C(ﾀ) then -> 砲台(ix, iy)
						when $C(ﾝ) then -> ハンマーブロス(ix, iy)
						when $C(ｯ) then -> クッパ(ix, iy)
						when $C(ｹ) then -> ゲッソー(ix, iy)
						else if 0x40 <= cell and cell <= 0x6f then -> PlatformBlock(ix, iy, {cell+@sprites_offset}) -- 動かないブロック(見た目は色々)
					@schedule[] = {ix, iy, f}
					@field[y][x] = 0
		-- for y, row in ipairs @field  アスキー文字で表せる以外の範囲に背景チップを置く仕組み→タイトルでも使うのでとりあえず採用は保留
		-- 	for x, cell in ipairs row
		-- 		switch cell
		-- 			when 0x25 then if @field[y+1][x] == 0 then @field[y+1][x] = 0x5
		setmetatable(@field, {__index: -> @field[1]}) -- 範囲チェックを不要とする(一行目は必ず000..なのでそれを使う)
		@schedule = lume.sort(@schedule, (a,b)->a[1]<b[1])
		@schedule[] = {lume.maxinteger, 0, 0} -- 長さチェックを不要にするため一つ付けておく
		@.Player(unpack startpoints[math.max(1, lume.count(startpoints, (p)-> @old_player_x > p[1]))])
		BGM(@bgm)

	update: (dt)=>
		@time -= dt * 2.5 -- 1カウント0.4秒だそうだ
		@updateTheOtherObjects(dt)
		for {x, y, key: key, action: action} in *Scene.current.warppoints -- ワープポイント
			if #(Scene.current.world\queryPoint(x, y, (item)-> issubclass(item.__class, _Player))) > 0 and input[key--[[..'p']]]() then action()
		if math.floor(@time) == 100 and love.BGM.filename != 'assets/supermario/警告音.ogg' then BGM({'assets/supermario/警告音.ogg', ...@bgm})
		if @player.x >= @goal_x-8 then @update = coroutine.wrap(@_update_goal) -- ゴール
		-- if @泡time > 5 then @泡time, _ = @泡time-5, _Tooltip(@player.x+4, @player.y-6, 16, 16, {0x16f}, 10.0, -256) -- 水中ステージで泡を出す

	updateTheOtherObjects: (dt)=> -- 共通部分
		for c in *@charactors do c\update(dt)
		for c, r in pairs @world.rects do if r.x < -@scroll[1]-16-128 or 256 < r.y then c.y, _ = 257, @world\remove(c) -- 登録したかの情報がないので一緒にできない
		@charactors = [c for c in *@charactors when -@scroll[1]-16-128 <= c.x and c.y < 257] -- 画面左外-128(または落下)でオブジェクトを消滅させる
		while lume.first(@schedule)[1]+@scroll[1] < 256+96 do table.remove(@schedule, 1)[3]() -- 画面右外+96くらいでscheduleからブロックやモンスターを生み出す optimize: HTML5版で遅くならないように

	_update_player_died: (dt)=>
		BGM()
		play'assets/supermario/death.ogg'
		for _i = 1, 20 -- 60
			-- 	@updateTheOtherObjects(dt)
			_, dt = coroutine.yield()
		@player.dy = -7
		for _i = 1, 60*3
			@player.y += @player.dy
			@player.dy += 0.5
			@updateTheOtherObjects(dt)
			_, dt = coroutine.yield()
		love.lives -= 1
		love.hiscore = math.max(love.hiscore, love.score)
		love.filesystem.write(PROJECTNAME..'.save', lume.serialize({hiscore: love.hiscore})) -- save hiscore
		Scene.current = if love.lives == 0 then GameOver(@level) else Ready(@level, nil, @player.x)

	_update_powerup: (_)=>
		for _i=1, 60 do _, _ = coroutine.yield()
		@update = nil

	_update土管入り: (action)=>
		play'assets/supermario/土管.ogg'
		@player.sprites.z = -1
		y = 0
		while y < 32
			_, dt = coroutine.yield()
			y += dt * 60
			@player.y += dt * 60
			@world\update(@player, @player.x, @player.y)
		action()

	_update土管出: =>
		@updateTheOtherObjects(0) -- オブジェクト生成のため
		play'assets/supermario/土管.ogg'
		-- love.BGM.source\pause()
		@player.sprites.z = -1
		y = 0
		@player.y += 32--16+@player.h
		while y < 16+@player.h
			_, dt = coroutine.yield()
			y += dt * 60
			@player.y -= dt * 60
			@world\update(@player, @player.x, @player.y)
		Scene.current.update = nil
		-- love.BGM.source\play()
		@player.sprites.z = 1
	
	_update_goal: (dt)=>
		BGM()
		n = if @player.y > 116 then 400 elseif @player.y > 82 then 1000 elseif @player.y > 65 then 2000 elseif @player.y > 50 then 4000 elseif @player.y > 42 then 8000 else '1UP'
		@player.y = math.max(@player.y, 8+2*16-@player.h+16)
		player = if @player.__class == チビマリオ then _Charactor(@goal_x-16, @player.y, 16, 16, {0x107}) elseif @player.__class == スーパーマリオ then _Charactor(@goal_x-16, @player.y, 16, 32, {0x127, 0x137}) else _Charactor(@goal_x-16, @player.y, 16, 32, {0x12f, 0x13f})
		score, flag, scoretip = love.score + (if n != '1UP' then n else 0), _Charactor(@goal_x-16, 160+8+16, 16, 16, {0x1f0, z: -1}), _Charactor(@goal_x+4, 160+8+16, 16, 16, ScoreTooltip.Sprites[n])
		if n == '1UP' then love.lives, _ = love.lives+1, play'assets/supermario/1UP.ogg'
		@charactors = [c for c in *@charactors when issubclass(c.__class, _Block)] |>lume.concat {player, flag, scoretip} -- ブロック以外を消す
		for _i = 0, 60 do _, dt = coroutine.yield() -- wait
		sound = play'assets/supermario/ポール.ogg'
		for y = player.y, 176+8-player.h
			player.y, flag.y, scoretip.y = y, flag.y-1, scoretip.y-1
			_, dt = coroutine.yield()
		-- for _i = 0, 60 do _, dt = coroutine.yield()
		sound\stop()
		sound = play'assets/supermario/コースクリア.ogg'
		for i = @time-1, -1, -1
			@time = i
			love.score += 50
			_, dt = coroutine.yield()
		while sound\isPlaying() do  _, dt = coroutine.yield()
		Scene.current = Ready('1-1', @player.__class)

	draw: =>
		if @player.x > -@scroll[1]+128 then @scroll[1] = math.max(-@player.x+128, 256-16*#@field[1]) -- 土管出のとき、通常のupdateを通らないのでここでスクロールは計算
		gr.clear(@bgcolor)
		@@letters\set("   MARIO         WORLD   TIME\n   %06d  %s%s%02d   %s     %03d"\format(love.score, string.char(2.5+lume.pingpong(love.timer.getTime())*2), utf8.char(0xb5), love.coins, @level, @time+1)\to2d((c)->if c==0x20 then 0 else c)) -- HUD TIMEは401から始まって1を切った時点で１機失う
		@@letters\draw(0, 8)
		@bg_spr.spritebatch\clear()
		@bg_spr\set(@field, 0, 8) -- 背景
		for c in *lume.sort(@charactors, (a, b)-> (a.sprites.z or 0) < (b.sprites.z or 0))
			c\registerSprite(@bg_spr)
		@bg_spr\draw(lume.round(@scroll[1]), lume.round(@scroll[2])) -- 整数でないと汚い描画になる
		gr.print(love.timer.getFPS()..' FPS\n'..#@charactors..' Objects')


class Ready extends Scene
	new: (@level, @Player, @old_player_x = 0)=>
		@update = coroutine.wrap(@_update)
	_update: (dt)=>
		BGM()
		for _i = 1, 60*3 do _, _ = coroutine.yield() -- wait
		Field(@level, @Player, @old_player_x)\attach()

	draw: =>
		gr.clear(0,0,0)
		@@letters\set("   MARIO         WORLD   TIME\n   %06d  \2%s%02d   %s   \n\n\n\n\n\n\n\n\n\n\n            \12\13\n            \14\15 %s %02d"\format(love.score, utf8.char(0xb5), love.coins, @level, utf8.char(0xb5), love.lives)\to2d((c)->if c==0x20 then 0 else c))
		@@letters\draw(0, 8)

class GameOver extends Scene
	new: (@level)=>
		@update = coroutine.wrap(@_update)
	_update: (dt)=>
		play'assets/supermario/gameover.ogg'
		for _i = 1, 60*5 do _, _ = coroutine.yield() -- wait
		Scene.current = Title()
	draw: =>
		gr.clear(0,0,0)
		@@letters\set("   MARIO         WORLD   TIME\n   %06d  \2%s%02d   %s   \n\n\n\n\n\n\n\n\n\n\n\n           GAME OVER"\format(love.score, utf8.char(0xb5), love.coins, @level)\to2d((c)->if c==0x20 then 0 else c))
		@@letters\draw(0, 8)

class Title extends SelectBox
	new: =>
		super(SelectBox.buildButtons({'1', '2'}, {{8*6, 8*15+8, 120, 16}, {8*6, 8*17+8, 120, 16}}, {
			(-> love.score, love.lives, love.coins, Scene.current, _ = 0, 3, 0, Ready('1-1'), play'assets/supermario/コイン.ogg'),
			(-> love.score, love.lives, love.coins, Scene.current, _ = 0, 3, 0, Ready('1-1', ファイアマリオ), play'assets/supermario/コイン.ogg') }))
		{bgcolor: @bgcolor, field: field }  = LevelData['title']
		@bg_spr = with Map('assets/supermario/bg_spr_16x16.png', {16, 16})
			\set(lume.concat(field, {field[13], field[13], field[13]})) -- 地面を一行で表すようにしたため最後の行を繰り返しておく
		@title = gr.newFlyweightImage('assets/supermario/title.png')

	playClickSE: => -- 音鳴らさない
	draw: =>
		gr.clear(@bgcolor)
		@bg_spr\draw(-16, 8)
		@@letters\set("   MARIO         WORLD   TIME\n   %06d  %s%s%02d\n\n\n\n\n\n\n\n\n\n\n\n\n\n      %s 1 PLAYER GAME\n\n      %s 1 PLAYER GAME\n\n\n\n       TOP - %08d"\format(love.score,
			string.char(2.5+lume.pingpong(love.timer.getTime())*2), utf8.char(0xb5), love.coins, -- HTML5版で\u{XX}や\xXXが理解されずそのままの文字になるため
			(if 1 == @index then string.char(1) else ' '), (if 2 == @index then string.char(1) else ' '), love.hiscore)\to2d((c)-> if c==0x20 then 0 else c))
		@@letters\draw(0, 8)
		gr.draw(@title, 40, 16+8)


love.load = ->
	-- vudu?.initialize()
	-- vudu?.initializeDefaultHotkeys()
	{hiscore: love.hiscore = 0} = if love.filesystem.getInfo(PROJECTNAME..'.save') then lume.deserialize(love.filesystem.read(PROJECTNAME..'.save') or '{}') else {}
	Title()\attach()

	if DEBUGMODE -- hotswap
		Watchdog{
			"#{$FILE}": -> Watchdog.transpile("#{$FILE}", 'main.lua')
			'main.lua': -> lume.hotswap('main')
			'ui.yue': -> @@.transpile('ui.yue')
			'input.yue': -> @@.transpile('input.yue')
			-- 'color.yue': -> @@.transpile('color.yue')
			'utl.yue': -> @@.transpile('utl.yue')
			'bigmap.yue': -> @@.transpile('bigmap.yue')
			-- 'BDF.yue': -> @@.transpile('BDF.yue')
			-- 'distribute.yue': -> @@.transpile('distribute.yue')
			'main.lua': -> lume.hotswap('main')
			'input.lua': -> lume.hotswap('input')
			'ui.lua': -> lume.hotswap('ui')
			-- 'color.lua': -> lume.hotswap('color')
			'utl.lua': -> lume.hotswap('utl')
			'bigmap.lua': -> lume.hotswap('bigmap')
			-- 'BDF.lua': -> lume.hotswap('BDF')
			-- 'distribute.lua': -> lume.hotswap('distribute')
			}
	if DEBUGMODE -- build
		love.thread.newThread([[
_G.PROJECTNAME, _G.VERSION = ...
require('distribute').build({'lib/bump.lua', })
]])\start(PROJECTNAME, VERSION)
